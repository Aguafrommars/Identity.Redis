<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\projects\identity-redis\src\Aguacongas.Identity.Redis\UserOnlyStore.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using Microsoft.AspNetCore.Identity;
using Newtonsoft.Json;
using StackExchange.Redis;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Security.Claims;
using System.Threading;
using System.Threading.Tasks;

namespace Aguacongas.Identity.Redis
{
    /// &lt;summary&gt;
    /// Represents a new instance of a persistence store for &lt;see cref=&quot;IdentityUser&quot;/&gt;.
    /// &lt;/summary&gt;
    public class UserOnlyStore : UserOnlyStore&lt;string&gt;
    {
        /// &lt;summary&gt;
        /// Constructs a new instance of &lt;see cref=&quot;UserStore{TUser, TRole, TKey}&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;db&quot;&gt;The &lt;see cref=&quot;IDatabase&quot;/&gt;.&lt;/param&gt;
        /// &lt;param name=&quot;describer&quot;&gt;The &lt;see cref=&quot;IdentityErrorDescriber&quot;/&gt;.&lt;/param&gt;
        public UserOnlyStore(IDatabase db, IdentityErrorDescriber describer = null) : base(db, describer) { }
    }

    /// &lt;summary&gt;
    /// Represents a new instance of a persistence store for &lt;see cref=&quot;IdentityUser&quot;/&gt;.
    /// &lt;/summary&gt;
    public class UserOnlyStore&lt;TKey&gt;: UserOnlyStore&lt;IdentityUser&lt;TKey&gt;, TKey&gt;
        where TKey : IEquatable&lt;TKey&gt;
    {
        /// &lt;summary&gt;
        /// Constructs a new instance of &lt;see cref=&quot;UserStore{TUser, TRole, TKey}&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;db&quot;&gt;The &lt;see cref=&quot;IDatabase&quot;/&gt;.&lt;/param&gt;
        /// &lt;param name=&quot;describer&quot;&gt;The &lt;see cref=&quot;IdentityErrorDescriber&quot;/&gt;.&lt;/param&gt;
        public UserOnlyStore(IDatabase db, IdentityErrorDescriber describer = null) : base(db, describer) { }
    }

    /// &lt;summary&gt;
    /// Represents a new instance of a persistence store for the specified user and role types.
    /// &lt;/summary&gt;
    /// &lt;typeparam name=&quot;TUser&quot;&gt;The type representing a user.&lt;/typeparam&gt;
    public class UserOnlyStore&lt;TUser, TKey&gt; : UserOnlyStore&lt;TUser, TKey, IdentityUserClaim&lt;TKey&gt;, IdentityUserLogin&lt;TKey&gt;, IdentityUserToken&lt;TKey&gt;&gt;
        where TUser : IdentityUser&lt;TKey&gt;
        where TKey : IEquatable&lt;TKey&gt;
    {
        /// &lt;summary&gt;
        /// Constructs a new instance of &lt;see cref=&quot;UserStore{TUser, TRole, TKey}&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;db&quot;&gt;The &lt;see cref=&quot;IDatabase&quot;/&gt;.&lt;/param&gt;
        /// &lt;param name=&quot;describer&quot;&gt;The &lt;see cref=&quot;IdentityErrorDescriber&quot;/&gt;.&lt;/param&gt;
        public UserOnlyStore(IDatabase db, IdentityErrorDescriber describer = null) : base(db, describer) { }
    }

    /// &lt;summary&gt;
    /// Represents a new instance of a persistence store for the specified user and role types.
    /// &lt;/summary&gt;
    /// &lt;typeparam name=&quot;TUser&quot;&gt;The type representing a user.&lt;/typeparam&gt;
    /// &lt;typeparam name=&quot;TUserClaim&quot;&gt;The type representing a claim.&lt;/typeparam&gt;
    /// &lt;typeparam name=&quot;TUserLogin&quot;&gt;The type representing a user external login.&lt;/typeparam&gt;
    /// &lt;typeparam name=&quot;TUserToken&quot;&gt;The type representing a user token.&lt;/typeparam&gt;
    public class UserOnlyStore&lt;TUser, TKey, TUserClaim, TUserLogin, TUserToken&gt; :
        RedisUserStoreBase&lt;TUser, TKey, TUserClaim, TUserLogin, TUserToken&gt;,
        IUserLoginStore&lt;TUser&gt;,
        IUserClaimStore&lt;TUser&gt;,
        IUserPasswordStore&lt;TUser&gt;,
        IUserSecurityStampStore&lt;TUser&gt;,
        IUserEmailStore&lt;TUser&gt;,
        IUserLockoutStore&lt;TUser&gt;,
        IUserPhoneNumberStore&lt;TUser&gt;,
        IUserTwoFactorStore&lt;TUser&gt;,
        IUserAuthenticationTokenStore&lt;TUser&gt;,
        IUserAuthenticatorKeyStore&lt;TUser&gt;,
        IUserTwoFactorRecoveryCodeStore&lt;TUser&gt;
        where TUser : IdentityUser&lt;TKey&gt;
        where TKey : IEquatable&lt;TKey&gt;
        where TUserClaim : IdentityUserClaim&lt;TKey&gt;, new()
        where TUserLogin : IdentityUserLogin&lt;TKey&gt;, new()
        where TUserToken : IdentityUserToken&lt;TKey&gt;, new()
    {
        private const string UsersRedisKey = &quot;users&quot;;
        private const string UsersConcurencyStampIndexKey = &quot;users-concurency&quot;;
        private const string UsersNameIndexKey = &quot;users-name&quot;;
        private const string UsersEmailIndexKey = &quot;users-email&quot;;
        private const string UserLoginsRedisKey = &quot;user-logins&quot;;
        private const string UserLoginProviderKeyPrefix = &quot;login-provider-&quot;;
        private const string UserClaimsRedisKey = &quot;user-claims&quot;;
        private const string UserClaimsKeyPrefix = &quot;user-claim-&quot;;
        private const string UserTokensRedisKey = &quot;user-tokens&quot;;

        private readonly IDatabase _db;

        /// &lt;summary&gt;
        /// A navigation property for the users the store contains.
        /// &lt;/summary&gt;
        public override IQueryable&lt;TUser&gt; Users
        {
            get
            {
                var results = _db.HashGetAll(UsersRedisKey);
                return results.Select(u =&gt; JsonConvert.DeserializeObject&lt;TUser&gt;(u.Value))
                    .AsQueryable();
            }
        }

        /// &lt;summary&gt;
        /// Creates a new instance of the store.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;db&quot;&gt;The &lt;see cref=&quot;IDatabase&quot;/&gt;.&lt;/param&gt;
        /// &lt;param name=&quot;describer&quot;&gt;The &lt;see cref=&quot;IdentityErrorDescriber&quot;/&gt; used to describe store errors.&lt;/param&gt;
        public UserOnlyStore(IDatabase db, IdentityErrorDescriber describer = null) : base(describer ?? new IdentityErrorDescriber())
        {
            _db = db ?? throw new ArgumentNullException(nameof(db));
        }

        /// &lt;summary&gt;
        /// Creates the specified &lt;paramref name=&quot;user&quot;/&gt; in the user store.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to create.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation, containing the &lt;see cref=&quot;IdentityResult&quot;/&gt; of the creation operation.&lt;/returns&gt;
        public async override Task&lt;IdentityResult&gt; CreateAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            var userId = ConvertIdToString(user.Id);

            user.ConcurrencyStamp = &quot;0&quot;;
            var tran = _db.CreateTransaction();
            var userNotExistsCondition = tran.AddCondition(Condition.HashNotExists(UsersRedisKey, userId));
#pragma warning disable CS4014 // Because this call is not awaited, execution of the current method continues before the call is completed
            tran.HashSetAsync(UsersRedisKey, userId, JsonConvert.SerializeObject(user));
            tran.HashSetAsync(UsersConcurencyStampIndexKey, userId, GetConcurrencyStamp(user));
            tran.HashSetAsync(UsersNameIndexKey, user.NormalizedUserName, userId);
            if (!string.IsNullOrEmpty(user.NormalizedEmail))
            {
                tran.HashSetAsync(UsersEmailIndexKey, user.NormalizedEmail, userId);
            }
#pragma warning restore CS4014 // Because this call is not awaited, execution of the current method continues before the call is completed

            if (!await tran.ExecuteAsync())
            {
                return IdentityResult.Failed(new IdentityError
                {
                    Code = nameof(userNotExistsCondition),
                    Description = $&quot;User id: {user.Id} already exists&quot;
                });
            }

            return IdentityResult.Success;
        }

        /// &lt;summary&gt;
        /// Updates the specified &lt;paramref name=&quot;user&quot;/&gt; in the user store.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to update.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation, containing the &lt;see cref=&quot;IdentityResult&quot;/&gt; of the update operation.&lt;/returns&gt;
        public async override Task&lt;IdentityResult&gt; UpdateAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            var userId = ConvertIdToString(user.Id);

            var tran = _db.CreateTransaction();
            tran.AddCondition(Condition.HashEqual(UsersConcurencyStampIndexKey, userId, GetConcurrencyStamp(user)));
#pragma warning disable CS4014 // Because this call is not awaited, execution of the current method continues before the call is completed
            tran.HashSetAsync(UsersRedisKey, userId, JsonConvert.SerializeObject(user));
            var concurency = tran.HashIncrementAsync(UsersConcurencyStampIndexKey, userId);
            tran.HashSetAsync(UsersNameIndexKey, user.NormalizedUserName, userId);
            if (!string.IsNullOrEmpty(user.NormalizedEmail))
            {
                tran.HashSetAsync(UsersEmailIndexKey, user.NormalizedEmail, userId);
            }
#pragma warning restore CS4014 // Because this call is not awaited, execution of the current method continues before the call is completed

            if (!await tran.ExecuteAsync())
            {
                return IdentityResult.Failed(ErrorDescriber.ConcurrencyFailure());
            }
            user.ConcurrencyStamp = concurency.Result.ToString();

            return IdentityResult.Success;
        }

        /// &lt;summary&gt;
        /// Deletes the specified &lt;paramref name=&quot;user&quot;/&gt; from the user store.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to delete.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation, containing the &lt;see cref=&quot;IdentityResult&quot;/&gt; of the update operation.&lt;/returns&gt;
        public async override Task&lt;IdentityResult&gt; DeleteAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            var userId = ConvertIdToString(user.Id);

            var tran = _db.CreateTransaction();
            var concurencyStampMatchCondition = tran.AddCondition(Condition.HashEqual(UsersConcurencyStampIndexKey, userId, GetConcurrencyStamp(user)));
#pragma warning disable CS4014 // Because this call is not awaited, execution of the current method continues before the call is completed
            tran.HashDeleteAsync(UsersRedisKey, userId);
            tran.HashDeleteAsync(UsersNameIndexKey, user.NormalizedUserName);
            if (user.NormalizedEmail != null)
            {
                tran.HashDeleteAsync(UsersNameIndexKey, user.NormalizedEmail);
            }
#pragma warning restore CS4014 // Because this call is not awaited, execution of the current method continues before the call is completed

            if (!await tran.ExecuteAsync())
            {
                return IdentityResult.Failed(ErrorDescriber.ConcurrencyFailure());
            }

            return IdentityResult.Success;
        }

        public async override Task SetNormalizedUserNameAsync(TUser user, string normalizedName, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            if (user.NormalizedEmail == normalizedName)
            {
                return;
            }

            var userId = ConvertIdToString(user.Id);

            var tran = _db.CreateTransaction();
            var concurencyStampMatchCondition = tran.AddCondition(Condition.HashEqual(UsersConcurencyStampIndexKey, userId, GetConcurrencyStamp(user)));
#pragma warning disable CS4014 // Because this call is not awaited, execution of the current method continues before the call is completed
            if (user.NormalizedUserName != null)
            {
                tran.HashDeleteAsync(UsersNameIndexKey, user.NormalizedUserName);
            }
            if (normalizedName != null)
            {
                tran.HashSetAsync(UsersNameIndexKey, normalizedName, userId);
            }
#pragma warning restore CS4014 // Because this call is not awaited, execution of the current method continues before the call is completed

            if (!await tran.ExecuteAsync())
            {
                throw new DBConcurrencyException($&quot;ConcurrencyStamp {user.ConcurrencyStamp} doesn&#39;t match for user: {user.Id}&quot;);
            }

            user.NormalizedUserName = normalizedName;
        }

        public async override Task SetNormalizedEmailAsync(TUser user, string normalizedEmail, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            if (user.NormalizedEmail == normalizedEmail)
            {
                return;
            }

            var userId = ConvertIdToString(user.Id);

            var tran = _db.CreateTransaction();
            var concurencyStampMatchCondition = tran.AddCondition(Condition.HashEqual(UsersConcurencyStampIndexKey, userId, GetConcurrencyStamp(user)));
#pragma warning disable CS4014 // Because this call is not awaited, execution of the current method continues before the call is completed
            if (user.NormalizedEmail != null)
            {
                tran.HashDeleteAsync(UsersEmailIndexKey, user.NormalizedEmail);
            }
            if (normalizedEmail != null)
            {
                tran.HashSetAsync(UsersEmailIndexKey, normalizedEmail, userId);
            }
#pragma warning restore CS4014 // Because this call is not awaited, execution of the current method continues before the call is completed

            if (!await tran.ExecuteAsync())
            {
                throw new DBConcurrencyException($&quot;ConcurrencyStamp {user.ConcurrencyStamp} doesn&#39;t match for user: {user.Id}&quot;);
            }
            user.NormalizedEmail = normalizedEmail;
        }

        /// &lt;summary&gt;
        /// Finds and returns a user, if any, who has the specified &lt;paramref name=&quot;userId&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;userId&quot;&gt;The user ID to search for.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation, containing the user matching the specified &lt;paramref name=&quot;userId&quot;/&gt; if it exists.
        /// &lt;/returns&gt;
        public override async Task&lt;TUser&gt; FindByIdAsync(string userId, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();

            var response = await _db.HashGetAsync(UsersRedisKey, userId);
            if (response.HasValue)
            {
                var user = JsonConvert.DeserializeObject&lt;TUser&gt;(response);
                user.ConcurrencyStamp = (await _db.HashGetAsync(UsersConcurencyStampIndexKey, userId)).ToString();

                return user;
            }
            return default(TUser);
        }

        /// &lt;summary&gt;
        /// Finds and returns a user, if any, who has the specified normalized user name.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;normalizedUserName&quot;&gt;The normalized user name to search for.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation, containing the user matching the specified &lt;paramref name=&quot;normalizedUserName&quot;/&gt; if it exists.
        /// &lt;/returns&gt;
        public override async Task&lt;TUser&gt; FindByNameAsync(string normalizedUserName, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            var userId = await _db.HashGetAsync(UsersNameIndexKey, normalizedUserName);
            if (!userId.HasValue)
            {
                return default(TUser);
            }

            return await FindByIdAsync(userId, cancellationToken);
        }

        /// &lt;summary&gt;
        /// Get the claims associated with the specified &lt;paramref name=&quot;user&quot;/&gt; as an asynchronous operation.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user whose claims should be retrieved.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;A &lt;see cref=&quot;Task{TResult}&quot;/&gt; that contains the claims granted to a user.&lt;/returns&gt;
        public async override Task&lt;IList&lt;Claim&gt;&gt; GetClaimsAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            var userId = ConvertIdToString(user.Id);

            var response = await _db.HashGetAsync(UserClaimsRedisKey, userId);
            if (response.HasValue)
            {
                var claims = JsonConvert.DeserializeObject&lt;List&lt;TUserClaim&gt;&gt;(response);
                return claims.Select(c =&gt; c.ToClaim()).ToList();
            }

            return new List&lt;Claim&gt;(0);
        }

        /// &lt;summary&gt;
        /// Adds the &lt;paramref name=&quot;claims&quot;/&gt; given to the specified &lt;paramref name=&quot;user&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to add the claim to.&lt;/param&gt;
        /// &lt;param name=&quot;claims&quot;&gt;The claim to add to the user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation.&lt;/returns&gt;
        public override async Task AddClaimsAsync(TUser user, IEnumerable&lt;Claim&gt; claims, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            if (claims == null)
            {
                throw new ArgumentNullException(nameof(claims));
            }

            var userClaims = await GetUserClaimsAsync(user);

            userClaims.AddRange(claims.Select(c =&gt; CreateUserClaim(user, c)));

            var userId = ConvertIdToString(user.Id);

            var taskList = new List&lt;Task&gt;(claims.Count() + 1);
            taskList.Add(_db.HashSetAsync(UserClaimsRedisKey, userId, JsonConvert.SerializeObject(userClaims)));
            foreach (var claim in claims)
            {
                taskList.Add(_db.HashSetAsync(UserClaimsKeyPrefix + claim.Type, userId, claim.Value));
            }

            await Task.WhenAll(taskList);
        }

        /// &lt;summary&gt;
        /// Replaces the &lt;paramref name=&quot;claim&quot;/&gt; on the specified &lt;paramref name=&quot;user&quot;/&gt;, with the &lt;paramref name=&quot;newClaim&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to replace the claim on.&lt;/param&gt;
        /// &lt;param name=&quot;claim&quot;&gt;The claim replace.&lt;/param&gt;
        /// &lt;param name=&quot;newClaim&quot;&gt;The new claim replacing the &lt;paramref name=&quot;claim&quot;/&gt;.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation.&lt;/returns&gt;
        public async override Task ReplaceClaimAsync(TUser user, Claim claim, Claim newClaim, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            if (claim == null)
            {
                throw new ArgumentNullException(nameof(claim));
            }
            if (newClaim == null)
            {
                throw new ArgumentNullException(nameof(newClaim));
            }

            var userId = ConvertIdToString(user.Id);

            var userClaims = await GetUserClaimsAsync(user);
            var taskList = new List&lt;Task&gt;(3);
            await Task.WhenAll(taskList);
            foreach (var uc in userClaims)
            {
                if (uc.ClaimType == claim.Type &amp;&amp; uc.ClaimValue == claim.Value)
                {
                    uc.ClaimType = newClaim.Type;
                    uc.ClaimValue = newClaim.Value;
                    taskList.Add(_db.HashDeleteAsync(UserClaimsKeyPrefix + claim.Type, userId));
                    taskList.Add(_db.HashSetAsync(UserClaimsKeyPrefix + newClaim.Type, userId, newClaim.Value));
                }
            }

            taskList.Add(_db.HashSetAsync(UserClaimsRedisKey, userId, JsonConvert.SerializeObject(userClaims)));
            await Task.WhenAll(taskList);
        }

        /// &lt;summary&gt;
        /// Removes the &lt;paramref name=&quot;claims&quot;/&gt; given from the specified &lt;paramref name=&quot;user&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to remove the claims from.&lt;/param&gt;
        /// &lt;param name=&quot;claims&quot;&gt;The claim to remove.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation.&lt;/returns&gt;
        public async override Task RemoveClaimsAsync(TUser user, IEnumerable&lt;Claim&gt; claims, CancellationToken cancellationToken = default(CancellationToken))
        {
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            if (claims == null)
            {
                throw new ArgumentNullException(nameof(claims));
            }

            var userId = ConvertIdToString(user.Id);

            var userClaims = await GetUserClaimsAsync(user);
            var taskList = new List&lt;Task&gt;(claims.Count() + 1);
            foreach (var claim in claims)
            {
                userClaims.RemoveAll(uc =&gt; uc.ClaimType == claim.Type &amp;&amp; uc.ClaimValue == claim.Value);
                taskList.Add(_db.HashDeleteAsync(UserClaimsKeyPrefix + claim.Type, userId));
            }

            taskList.Add(_db.HashSetAsync(UserClaimsRedisKey, userId, JsonConvert.SerializeObject(userClaims)));

            await Task.WhenAll(taskList);
        }

        /// &lt;summary&gt;
        /// Adds the &lt;paramref name=&quot;login&quot;/&gt; given to the specified &lt;paramref name=&quot;user&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to add the login to.&lt;/param&gt;
        /// &lt;param name=&quot;login&quot;&gt;The login to add to the user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation.&lt;/returns&gt;
        public override async Task AddLoginAsync(TUser user, UserLoginInfo login,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            if (login == null)
            {
                throw new ArgumentNullException(nameof(login));
            }

            var userId = ConvertIdToString(user.Id);

            var logins = await GetUserLoginsAsync(userId);
            logins.Add(CreateUserLogin(user, login));

            await _db.HashSetAsync(UserLoginsRedisKey, userId, JsonConvert.SerializeObject(logins));
            await _db.HashSetAsync(UserLoginProviderKeyPrefix + login.LoginProvider, login.ProviderKey, userId);
        }

        /// &lt;summary&gt;
        /// Removes the &lt;paramref name=&quot;loginProvider&quot;/&gt; given from the specified &lt;paramref name=&quot;user&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to remove the login from.&lt;/param&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login to remove from the user.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation.&lt;/returns&gt;
        public override async Task RemoveLoginAsync(TUser user, string loginProvider, string providerKey,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            var userId = ConvertIdToString(user.Id);

            var logins = await GetUserLoginsAsync(userId);
            logins.RemoveAll(l =&gt; l.LoginProvider == loginProvider &amp;&amp; l.ProviderKey == providerKey);

            await _db.HashSetAsync(UserLoginsRedisKey, userId, JsonConvert.SerializeObject(logins));
            await _db.HashDeleteAsync(UserLoginProviderKeyPrefix + loginProvider, providerKey);
        }

        /// &lt;summary&gt;
        /// Retrieves the associated logins for the specified &lt;param ref=&quot;user&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user whose associated logins to retrieve.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The &lt;see cref=&quot;Task&quot;/&gt; for the asynchronous operation, containing a list of &lt;see cref=&quot;UserLoginInfo&quot;/&gt; for the specified &lt;paramref name=&quot;user&quot;/&gt;, if any.
        /// &lt;/returns&gt;
        public async override Task&lt;IList&lt;UserLoginInfo&gt;&gt; GetLoginsAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            var userId = ConvertIdToString(user.Id);

            var logins = await GetUserLoginsAsync(userId);

            return logins
                .Select(l =&gt; new UserLoginInfo(l.LoginProvider, l.ProviderKey, l.ProviderDisplayName))
                .ToList();
        }

        /// &lt;summary&gt;
        /// Retrieves the user associated with the specified login provider and login provider key.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login provider who provided the &lt;paramref name=&quot;providerKey&quot;/&gt;.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The &lt;see cref=&quot;Task&quot;/&gt; for the asynchronous operation, containing the user, if any which matched the specified login provider and key.
        /// &lt;/returns&gt;
        public async override Task&lt;TUser&gt; FindByLoginAsync(string loginProvider, string providerKey,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            var userLogin = await FindUserLoginAsync(loginProvider, providerKey, cancellationToken);
            if (userLogin != null)
            {
                return await FindUserAsync(userLogin.UserId, cancellationToken);
            }
            return null;
        }

        /// &lt;summary&gt;
        /// Gets the user, if any, associated with the specified, normalized email address.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;normalizedEmail&quot;&gt;The normalized email address to return the user for.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The task object containing the results of the asynchronous lookup operation, the user if any associated with the specified normalized email address.
        /// &lt;/returns&gt;
        public override async Task&lt;TUser&gt; FindByEmailAsync(string normalizedEmail, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();

            var response = await _db.HashGetAsync(UsersEmailIndexKey, normalizedEmail);
            if (response.HasValue)
            {
                return await FindByIdAsync(response, cancellationToken);
            }

            return default(TUser);
        }

        /// &lt;summary&gt;
        /// Retrieves all users with the specified claim.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;claim&quot;&gt;The claim whose users should be retrieved.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The &lt;see cref=&quot;Task&quot;/&gt; contains a list of users, if any, that contain the specified claim. 
        /// &lt;/returns&gt;
        public async override Task&lt;IList&lt;TUser&gt;&gt; GetUsersForClaimAsync(Claim claim, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (claim == null)
            {
                throw new ArgumentNullException(nameof(claim));
            }

            var result = await _db.HashGetAllAsync(UserClaimsKeyPrefix + claim.Type);

            var users = new ConcurrentBag&lt;TUser&gt;();
            var taskList = new List&lt;Task&gt;(result.Length);
            foreach (var uc in result)
            {
                taskList.Add(Task.Run(async () =&gt; {
                    var user = await FindByIdAsync(uc.Name, cancellationToken);
                    if (user != null)
                    {
                        users.Add(user);
                    }
                }));
            }

            Task.WaitAll(taskList.ToArray());

            return users.ToList();
        }

        /// &lt;summary&gt;
        /// Return a user login with the matching userId, provider, providerKey if it exists.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;userId&quot;&gt;The user&#39;s id.&lt;/param&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login provider name.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The user login if it exists.&lt;/returns&gt;
        internal Task&lt;TUserLogin&gt; FindUserLoginInternalAsync(string userId, string loginProvider, string providerKey, CancellationToken cancellationToken)
        {
            return FindUserLoginAsync(userId, loginProvider, providerKey, cancellationToken);
        }

        /// &lt;summary&gt;
        /// Return a user login with  provider, providerKey if it exists.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login provider name.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The user login if it exists.&lt;/returns&gt;
        internal Task&lt;TUserLogin&gt; FindUserLoginInternalAsync(string loginProvider, string providerKey, CancellationToken cancellationToken)
        {
            return FindUserLoginAsync(loginProvider, providerKey, cancellationToken);
        }

        /// &lt;summary&gt;
        /// Get user tokens
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The token owner.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;User tokens.&lt;/returns&gt;
        internal Task&lt;List&lt;TUserToken&gt;&gt; GetUserTokensInternalAsync(TUser user, CancellationToken cancellationToken)
        {
            return GetUserTokensAsync(user, cancellationToken);
        }

        /// &lt;summary&gt;
        /// Save user tokens.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The tokens owner.&lt;/param&gt;
        /// &lt;param name=&quot;tokens&quot;&gt;Tokens to save&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        internal Task SaveUserTokensInternalAsync(TUser user, IEnumerable&lt;TUserToken&gt; tokens, CancellationToken cancellationToken)
        {
            return SaveUserTokensAsync(user, tokens, cancellationToken);
        }
        
        /// &lt;summary&gt;
        /// Return a user with the matching userId if it exists.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;userId&quot;&gt;The user&#39;s id.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The user if it exists.&lt;/returns&gt;
        protected override Task&lt;TUser&gt; FindUserAsync(TKey userId, CancellationToken cancellationToken)
        {
            return FindByIdAsync(userId.ToString(), cancellationToken);
        }

        /// &lt;summary&gt;
        /// Return a user login with the matching userId, provider, providerKey if it exists.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;userId&quot;&gt;The user&#39;s id.&lt;/param&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login provider name.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The user login if it exists.&lt;/returns&gt;
        protected override async Task&lt;TUserLogin&gt; FindUserLoginAsync(string userId, string loginProvider, string providerKey, CancellationToken cancellationToken)
        {
            var data = await GetUserLoginsAsync(userId);
            if (data != null)
            {
                return data.FirstOrDefault(l =&gt; l.LoginProvider == loginProvider &amp;&amp; l.ProviderKey == providerKey);
            }
            return null;
        }

        /// &lt;summary&gt;
        /// Return a user login with  provider, providerKey if it exists.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login provider name.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The user login if it exists.&lt;/returns&gt;
        protected override async Task&lt;TUserLogin&gt; FindUserLoginAsync(string loginProvider, string providerKey, CancellationToken cancellationToken)
        {
            var userId = await _db.HashGetAsync(UserLoginProviderKeyPrefix + loginProvider, providerKey);

            if (userId.HasValue)
            {
                var logins = await GetUserLoginsAsync(userId);
                return logins.FirstOrDefault(l =&gt; l.LoginProvider == loginProvider &amp;&amp; l.ProviderKey == providerKey);
            }

            return default(TUserLogin);
        }

        /// &lt;summary&gt;
        /// Get user tokens
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The token owner.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;User tokens.&lt;/returns&gt;
        protected override async Task&lt;List&lt;TUserToken&gt;&gt; GetUserTokensAsync(TUser user, CancellationToken cancellationToken)
        {
            var userId = ConvertIdToString(user.Id);

            var result = await _db.HashGetAsync(UserTokensRedisKey, userId);
            if (result.HasValue)
            {
                return JsonConvert.DeserializeObject&lt;List&lt;TUserToken&gt;&gt;(result);
            }
            return new List&lt;TUserToken&gt;(0);
        }

        /// &lt;summary&gt;
        /// Save user tokens.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The tokens owner.&lt;/param&gt;
        /// &lt;param name=&quot;tokens&quot;&gt;Tokens to save&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        protected override async Task SaveUserTokensAsync(TUser user, IEnumerable&lt;TUserToken&gt; tokens, CancellationToken cancellationToken)
        {
            var userId = ConvertIdToString(user.Id);

            await _db.HashSetAsync(UserTokensRedisKey, userId, JsonConvert.SerializeObject(tokens));
        }

        protected virtual async Task&lt;List&lt;TUserClaim&gt;&gt; GetUserClaimsAsync(TUser user)
        {
            var userId = ConvertIdToString(user.Id);

            var response = await _db.HashGetAsync(UserClaimsRedisKey, userId);
            if (response.HasValue)
            {
                return JsonConvert.DeserializeObject&lt;List&lt;TUserClaim&gt;&gt;(response);
            }

            return new List&lt;TUserClaim&gt;();
        }

        protected virtual async Task&lt;List&lt;TUserLogin&gt;&gt; GetUserLoginsAsync(string userId)
        {
            var response = await _db.HashGetAsync(UserLoginsRedisKey, userId);
            if (response.HasValue)
            {
                return JsonConvert.DeserializeObject&lt;List&lt;TUserLogin&gt;&gt;(response);
            }

            return new List&lt;TUserLogin&gt;();
        }

        private static int? GetConcurrencyStamp(TUser user)
        {
            if (int.TryParse(user.ConcurrencyStamp, out int stamp))
            {
                return stamp;
            }
            return null;
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[25,87,25,106,1],[25,107,25,108,1],[25,109,25,110,1],[39,87,39,106,1],[39,107,39,108,1],[39,109,39,110,1],[55,87,55,106,1],[55,107,55,108,1],[55,109,55,110,1],[102,13,102,14,1],[103,17,103,61,1],[104,17,104,44,1],[104,44,104,89,1],[104,89,105,36,1],[104,17,105,36,1],[106,13,106,14,1],[114,87,114,134,1],[115,9,115,10,1],[116,13,116,69,1],[117,9,117,10,1],[126,9,126,10,1],[127,13,127,62,1],[128,13,128,31,1],[129,13,129,30,1],[130,13,130,14,1],[131,17,131,63,1],[134,13,134,53,1],[136,13,136,41,1],[137,13,137,48,1],[138,13,138,108,1],[140,13,140,89,1],[141,13,141,96,1],[142,13,142,83,1],[143,13,143,61,1],[144,13,144,14,1],[145,17,145,85,1],[146,13,146,14,1],[149,13,149,44,1],[150,13,150,14,0],[151,17,155,20,0],[158,13,158,43,1],[159,9,159,10,1],[168,9,168,10,1],[169,13,169,62,1],[170,13,170,31,1],[171,13,171,30,1],[172,13,172,14,1],[173,17,173,63,1],[176,13,176,53,1],[178,13,178,48,1],[179,13,179,117,1],[181,13,181,89,1],[182,13,182,92,1],[183,13,183,83,1],[184,13,184,61,1],[185,13,185,14,1],[186,17,186,85,1],[187,13,187,14,1],[190,13,190,44,1],[191,13,191,14,0],[192,17,192,83,0],[194,13,194,66,1],[196,13,196,43,1],[197,9,197,10,1],[206,9,206,10,1],[207,13,207,62,1],[208,13,208,31,1],[209,13,209,30,1],[210,13,210,14,1],[211,17,211,63,1],[214,13,214,53,1],[216,13,216,48,1],[217,13,217,153,1],[219,13,219,57,1],[220,13,220,78,1],[221,13,221,46,1],[222,13,222,14,1],[223,17,223,79,1],[224,13,224,14,1],[227,13,227,44,1],[228,13,228,14,0],[229,17,229,83,0],[232,13,232,43,1],[233,9,233,10,1],[236,9,236,10,1],[237,13,237,62,1],[238,13,238,31,1],[239,13,239,30,1],[240,13,240,14,0],[241,17,241,63,0],[243,13,243,56,1],[244,13,244,14,0],[245,17,245,24,0],[248,13,248,53,1],[250,13,250,48,1],[251,13,251,153,1],[253,13,253,49,1],[254,13,254,14,1],[255,17,255,82,1],[256,13,256,14,1],[257,13,257,40,1],[258,13,258,14,1],[259,17,259,78,1],[260,13,260,14,1],[263,13,263,44,1],[264,13,264,14,0],[265,17,265,129,0],[268,13,268,54,1],[269,9,269,10,1],[272,9,272,10,1],[273,13,273,62,1],[274,13,274,31,1],[275,13,275,30,1],[276,13,276,14,0],[277,17,277,63,0],[279,13,279,57,1],[280,13,280,14,1],[281,17,281,24,1],[284,13,284,53,1],[286,13,286,48,1],[287,13,287,153,1],[289,13,289,46,1],[290,13,290,14,1],[291,17,291,80,1],[292,13,292,14,1],[293,13,293,41,1],[294,13,294,14,1],[295,17,295,80,1],[296,13,296,14,1],[299,13,299,44,1],[300,13,300,14,0],[301,17,301,129,0],[303,13,303,52,1],[304,9,304,10,1],[315,9,315,10,1],[316,13,316,62,1],[317,13,317,31,1],[319,13,319,74,1],[320,13,320,35,1],[321,13,321,14,1],[322,17,322,75,1],[323,17,323,115,1],[325,17,325,29,1],[327,13,327,35,1],[328,9,328,10,1],[339,9,339,10,1],[340,13,340,62,1],[341,13,341,31,1],[342,13,342,88,1],[343,13,343,34,1],[344,13,344,14,1],[345,17,345,39,1],[348,13,348,67,1],[349,9,349,10,1],[358,9,358,10,1],[359,13,359,62,1],[360,13,360,31,1],[361,13,361,30,1],[362,13,362,14,1],[363,17,363,63,1],[366,13,366,53,1],[368,13,368,79,1],[369,13,369,35,1],[370,13,370,14,1],[371,17,371,88,1],[372,17,372,43,1],[372,43,372,54,1],[372,54,372,65,1],[372,17,372,65,1],[375,13,375,39,0],[376,9,376,10,1],[386,9,386,10,1],[387,13,387,62,1],[388,13,388,31,1],[389,13,389,30,1],[390,13,390,14,1],[391,17,391,63,1],[393,13,393,32,1],[394,13,394,14,1],[395,17,395,65,1],[398,13,398,61,1],[400,13,400,52,1],[400,52,400,76,1],[400,76,400,79,1],[400,13,400,79,1],[402,13,402,53,1],[404,13,404,63,1],[405,13,405,113,1],[406,13,406,20,1],[406,22,406,31,1],[406,32,406,34,1],[406,35,406,41,1],[407,13,407,14,1],[408,17,408,103,1],[409,13,409,14,1],[411,13,411,42,1],[412,9,412,10,1],[423,9,423,10,1],[424,13,424,62,1],[425,13,425,31,1],[426,13,426,30,1],[427,13,427,14,1],[428,17,428,63,1],[430,13,430,31,1],[431,13,431,14,0],[432,17,432,64,0],[434,13,434,34,1],[435,13,435,14,0],[436,17,436,67,0],[439,13,439,53,1],[441,13,441,61,1],[442,13,442,46,1],[443,13,443,42,1],[444,13,444,20,1],[444,22,444,28,1],[444,29,444,31,1],[444,32,444,42,1],[445,13,445,14,1],[446,17,446,80,1],[447,17,447,18,1],[448,21,448,50,1],[449,21,449,52,1],[450,21,450,97,1],[451,21,451,113,1],[452,17,452,18,1],[453,13,453,14,1],[455,13,455,113,1],[456,13,456,42,1],[457,9,457,10,1],[467,9,467,10,1],[468,13,468,31,1],[469,13,469,30,1],[470,13,470,14,1],[471,17,471,63,1],[473,13,473,32,1],[474,13,474,14,1],[475,17,475,65,1],[478,13,478,53,1],[480,13,480,61,1],[481,13,481,63,1],[482,13,482,20,1],[482,22,482,31,1],[482,32,482,34,1],[482,35,482,41,1],[483,13,483,14,1],[484,17,484,44,1],[484,44,484,102,1],[484,102,484,104,1],[484,17,484,104,1],[485,17,485,93,1],[486,13,486,14,1],[488,13,488,113,1],[490,13,490,42,1],[491,9,491,10,1],[502,9,502,10,1],[503,13,503,62,1],[504,13,504,31,1],[505,13,505,30,1],[506,13,506,14,1],[507,17,507,63,1],[509,13,509,31,1],[510,13,510,14,1],[511,17,511,64,1],[514,13,514,53,1],[516,13,516,59,1],[517,13,517,54,1],[519,13,519,101,1],[520,13,520,113,1],[521,9,521,10,1],[533,9,533,10,1],[534,13,534,62,1],[535,13,535,31,1],[536,13,536,30,1],[537,13,537,14,1],[538,17,538,63,1],[541,13,541,53,1],[543,13,543,59,1],[544,13,544,35,1],[544,35,544,99,1],[544,99,544,101,1],[544,13,544,101,1],[546,13,546,101,1],[547,13,547,96,1],[548,9,548,10,1],[559,9,559,10,1],[560,13,560,62,1],[561,13,561,31,1],[562,13,562,30,1],[563,13,563,14,1],[564,17,564,63,1],[567,13,567,53,1],[569,13,569,59,1],[571,13,572,30,1],[572,30,572,102,1],[572,102,573,27,1],[571,13,573,27,1],[574,9,574,10,1],[587,9,587,10,1],[588,13,588,62,1],[589,13,589,31,1],[590,13,590,101,1],[591,13,591,35,1],[592,13,592,14,1],[593,17,593,81,1],[595,13,595,25,1],[596,9,596,10,1],[607,9,607,10,1],[608,13,608,62,1],[609,13,609,31,1],[611,13,611,88,1],[612,13,612,35,1],[613,13,613,14,1],[614,17,614,73,1],[617,13,617,35,1],[618,9,618,10,1],[629,9,629,10,1],[630,13,630,62,1],[631,13,631,31,1],[632,13,632,31,1],[633,13,633,14,0],[634,17,634,64,0],[637,13,637,86,1],[639,13,639,52,1],[640,13,640,58,1],[641,13,641,20,1],[641,22,641,28,1],[641,29,641,31,1],[641,32,641,38,1],[642,13,642,14,1],[643,17,643,51,1],[643,51,643,52,1],[643,52,644,21,1],[644,21,644,80,1],[644,80,645,21,1],[645,21,645,38,1],[645,38,646,21,1],[646,21,646,22,1],[646,22,647,25,1],[647,25,647,41,1],[647,41,648,21,1],[648,21,648,22,1],[648,22,649,17,1],[649,17,649,18,1],[649,18,649,21,1],[643,17,649,21,1],[650,13,650,14,1],[652,13,652,46,1],[654,13,654,35,1],[655,9,655,10,1],[666,9,666,10,0],[667,13,667,94,0],[668,9,668,10,0],[678,9,678,10,0],[679,13,679,86,0],[680,9,680,10,0],[689,9,689,10,1],[690,13,690,64,1],[691,9,691,10,1],[701,9,701,10,1],[702,13,702,73,1],[703,9,703,10,1],[712,9,712,10,1],[713,13,713,72,1],[714,9,714,10,1],[725,9,725,10,0],[726,13,726,57,0],[727,13,727,30,0],[728,13,728,14,0],[729,17,729,49,0],[729,49,729,113,0],[729,113,729,115,0],[729,17,729,115,0],[731,13,731,25,0],[732,9,732,10,0],[742,9,742,10,1],[743,13,743,106,1],[745,13,745,33,1],[746,13,746,14,1],[747,17,747,63,1],[748,17,748,51,1],[748,51,748,115,1],[748,115,748,117,1],[748,17,748,117,1],[751,13,751,40,1],[752,9,752,10,1],[761,9,761,10,1],[762,13,762,53,1],[764,13,764,77,1],[765,13,765,33,1],[766,13,766,14,1],[767,17,767,80,1],[769,13,769,44,1],[770,9,770,10,1],[780,9,780,10,1],[781,13,781,53,1],[783,13,783,101,1],[784,9,784,10,1],[787,9,787,10,1],[788,13,788,53,1],[790,13,790,79,1],[791,13,791,35,1],[792,13,792,14,1],[793,17,793,82,1],[796,13,796,43,1],[797,9,797,10,1],[800,9,800,10,1],[801,13,801,79,1],[802,13,802,35,1],[803,13,803,14,1],[804,17,804,82,1],[807,13,807,43,1],[808,9,808,10,1],[811,9,811,10,1],[812,13,812,68,1],[813,13,813,14,1],[814,17,814,30,1],[816,13,816,25,1],[817,9,817,10,1]]);
    </script>
  </body>
</html>