<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Projects\Perso\Identity.Redis\src\Aguacongas.Identity.Redis\UserOnlyStore.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using Microsoft.AspNetCore.Identity;
using Newtonsoft.Json;
using StackExchange.Redis;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Net;
using System.Security.Claims;
using System.Threading;
using System.Threading.Tasks;

namespace Aguacongas.Identity.Redis
{
    /// &lt;summary&gt;
    /// Represents a new instance of a persistence store for &lt;see cref=&quot;IdentityUser&quot;/&gt;.
    /// &lt;/summary&gt;
    public class UserOnlyStore : UserOnlyStore&lt;string&gt;
    {
        /// &lt;summary&gt;
        /// Constructs a new instance of &lt;see cref=&quot;UserStore{TUser, TRole, TKey}&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;db&quot;&gt;The &lt;see cref=&quot;IDatabase&quot;/&gt;.&lt;/param&gt;
        /// &lt;param name=&quot;describer&quot;&gt;The &lt;see cref=&quot;IdentityErrorDescriber&quot;/&gt;.&lt;/param&gt;
        public UserOnlyStore(IDatabase db, IdentityErrorDescriber describer = null) : base(db, describer) { }
    }

    /// &lt;summary&gt;
    /// Represents a new instance of a persistence store for &lt;see cref=&quot;IdentityUser&quot;/&gt;.
    /// &lt;/summary&gt;
    public class UserOnlyStore&lt;TKey&gt;: UserOnlyStore&lt;IdentityUser&lt;TKey&gt;, TKey&gt;
        where TKey : IEquatable&lt;TKey&gt;
    {
        /// &lt;summary&gt;
        /// Constructs a new instance of &lt;see cref=&quot;UserStore{TUser, TRole, TKey}&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;db&quot;&gt;The &lt;see cref=&quot;IDatabase&quot;/&gt;.&lt;/param&gt;
        /// &lt;param name=&quot;describer&quot;&gt;The &lt;see cref=&quot;IdentityErrorDescriber&quot;/&gt;.&lt;/param&gt;
        public UserOnlyStore(IDatabase db, IdentityErrorDescriber describer = null) : base(db, describer) { }
    }

    /// &lt;summary&gt;
    /// Represents a new instance of a persistence store for the specified user and role types.
    /// &lt;/summary&gt;
    /// &lt;typeparam name=&quot;TUser&quot;&gt;The type representing a user.&lt;/typeparam&gt;
    public class UserOnlyStore&lt;TUser, TKey&gt; : UserOnlyStore&lt;TUser, TKey, IdentityUserClaim&lt;TKey&gt;, IdentityUserLogin&lt;TKey&gt;, IdentityUserToken&lt;TKey&gt;&gt;
        where TUser : IdentityUser&lt;TKey&gt;
        where TKey : IEquatable&lt;TKey&gt;
    {
        /// &lt;summary&gt;
        /// Constructs a new instance of &lt;see cref=&quot;UserStore{TUser, TRole, TKey}&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;db&quot;&gt;The &lt;see cref=&quot;IDatabase&quot;/&gt;.&lt;/param&gt;
        /// &lt;param name=&quot;describer&quot;&gt;The &lt;see cref=&quot;IdentityErrorDescriber&quot;/&gt;.&lt;/param&gt;
        public UserOnlyStore(IDatabase db, IdentityErrorDescriber describer = null) : base(db, describer) { }
    }

    /// &lt;summary&gt;
    /// Represents a new instance of a persistence store for the specified user and role types.
    /// &lt;/summary&gt;
    /// &lt;typeparam name=&quot;TUser&quot;&gt;The type representing a user.&lt;/typeparam&gt;
    /// &lt;typeparam name=&quot;TUserClaim&quot;&gt;The type representing a claim.&lt;/typeparam&gt;
    /// &lt;typeparam name=&quot;TUserLogin&quot;&gt;The type representing a user external login.&lt;/typeparam&gt;
    /// &lt;typeparam name=&quot;TUserToken&quot;&gt;The type representing a user token.&lt;/typeparam&gt;
    public class UserOnlyStore&lt;TUser, TKey, TUserClaim, TUserLogin, TUserToken&gt; :
        RedisUserStoreBase&lt;TUser, TKey, TUserClaim, TUserLogin, TUserToken&gt;,
        IUserLoginStore&lt;TUser&gt;,
        IUserClaimStore&lt;TUser&gt;,
        IUserPasswordStore&lt;TUser&gt;,
        IUserSecurityStampStore&lt;TUser&gt;,
        IUserEmailStore&lt;TUser&gt;,
        IUserLockoutStore&lt;TUser&gt;,
        IUserPhoneNumberStore&lt;TUser&gt;,
        IUserTwoFactorStore&lt;TUser&gt;,
        IUserAuthenticationTokenStore&lt;TUser&gt;,
        IUserAuthenticatorKeyStore&lt;TUser&gt;,
        IUserTwoFactorRecoveryCodeStore&lt;TUser&gt;
        where TUser : IdentityUser&lt;TKey&gt;
        where TKey : IEquatable&lt;TKey&gt;
        where TUserClaim : IdentityUserClaim&lt;TKey&gt;, new()
        where TUserLogin : IdentityUserLogin&lt;TKey&gt;, new()
        where TUserToken : IdentityUserToken&lt;TKey&gt;, new()
    {
        private const string UsersRedisKey = &quot;users&quot;;
        private const string UsersConcurencyStampIndexKey = &quot;users-concurency&quot;;
        private const string UsersNameIndexKey = &quot;users-name&quot;;
        private const string UsersEmailIndexKey = &quot;users-email&quot;;
        private const string UserLoginsRedisKey = &quot;user-logins&quot;;
        private const string UserLoginProviderKeyPrefix = &quot;login-provider-&quot;;
        private const string UserClaimsRedisKey = &quot;user-claims&quot;;
        private const string UserClaimsKeyPrefix = &quot;user-claim-&quot;;
        private const string UserTokensRedisKey = &quot;user-tokens&quot;;

        private readonly IDatabase _db;

        /// &lt;summary&gt;
        /// A navigation property for the users the store contains.
        /// &lt;/summary&gt;
        public override IQueryable&lt;TUser&gt; Users
        {
            get
            {
                var results = _db.HashGetAll(UsersRedisKey);
                return results.Select(u =&gt; JsonConvert.DeserializeObject&lt;TUser&gt;(u.Value))
                    .AsQueryable();
            }
        }

        /// &lt;summary&gt;
        /// Creates a new instance of the store.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;db&quot;&gt;The &lt;see cref=&quot;IDatabase&quot;/&gt;.&lt;/param&gt;
        /// &lt;param name=&quot;describer&quot;&gt;The &lt;see cref=&quot;IdentityErrorDescriber&quot;/&gt; used to describe store errors.&lt;/param&gt;
        public UserOnlyStore(IDatabase db, IdentityErrorDescriber describer = null) : base(describer ?? new IdentityErrorDescriber())
        {
            _db = db ?? throw new ArgumentNullException(nameof(db));
        }

        /// &lt;summary&gt;
        /// Creates the specified &lt;paramref name=&quot;user&quot;/&gt; in the user store.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to create.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation, containing the &lt;see cref=&quot;IdentityResult&quot;/&gt; of the creation operation.&lt;/returns&gt;
        public async override Task&lt;IdentityResult&gt; CreateAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            var userId = ConvertIdToString(user.Id);

            user.ConcurrencyStamp = &quot;0&quot;;
            var tran = _db.CreateTransaction();
            var userNotExistsCondition = tran.AddCondition(Condition.HashNotExists(UsersRedisKey, userId));
#pragma warning disable CS4014 // Because this call is not awaited, execution of the current method continues before the call is completed
            tran.HashSetAsync(UsersRedisKey, userId, JsonConvert.SerializeObject(user));
            tran.HashSetAsync(UsersConcurencyStampIndexKey, userId, GetConcurrencyStamp(user));
            tran.HashSetAsync(UsersNameIndexKey, user.NormalizedUserName, userId);
            if (!string.IsNullOrEmpty(user.NormalizedEmail))
            {
                tran.HashSetAsync(UsersEmailIndexKey, user.NormalizedEmail, userId);
            }
#pragma warning restore CS4014 // Because this call is not awaited, execution of the current method continues before the call is completed

            if (!await tran.ExecuteAsync())
            {
                return IdentityResult.Failed(new IdentityError
                {
                    Code = nameof(userNotExistsCondition),
                    Description = $&quot;User id: {user.Id} already exists&quot;
                });
            }

            return IdentityResult.Success;
        }

        /// &lt;summary&gt;
        /// Updates the specified &lt;paramref name=&quot;user&quot;/&gt; in the user store.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to update.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation, containing the &lt;see cref=&quot;IdentityResult&quot;/&gt; of the update operation.&lt;/returns&gt;
        public async override Task&lt;IdentityResult&gt; UpdateAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            var userId = ConvertIdToString(user.Id);

            var tran = _db.CreateTransaction();
            tran.AddCondition(Condition.HashEqual(UsersConcurencyStampIndexKey, userId, GetConcurrencyStamp(user)));
#pragma warning disable CS4014 // Because this call is not awaited, execution of the current method continues before the call is completed
            tran.HashSetAsync(UsersRedisKey, userId, JsonConvert.SerializeObject(user));
            var concurency = tran.HashIncrementAsync(UsersConcurencyStampIndexKey, userId);
            tran.HashSetAsync(UsersNameIndexKey, user.NormalizedUserName, userId);
            if (!string.IsNullOrEmpty(user.NormalizedEmail))
            {
                tran.HashSetAsync(UsersEmailIndexKey, user.NormalizedEmail, userId);
            }
#pragma warning restore CS4014 // Because this call is not awaited, execution of the current method continues before the call is completed

            if (!await tran.ExecuteAsync())
            {
                return IdentityResult.Failed(ErrorDescriber.ConcurrencyFailure());
            }
            user.ConcurrencyStamp = concurency.Result.ToString();

            return IdentityResult.Success;
        }

        /// &lt;summary&gt;
        /// Deletes the specified &lt;paramref name=&quot;user&quot;/&gt; from the user store.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to delete.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation, containing the &lt;see cref=&quot;IdentityResult&quot;/&gt; of the update operation.&lt;/returns&gt;
        public async override Task&lt;IdentityResult&gt; DeleteAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            var userId = ConvertIdToString(user.Id);

            var tran = _db.CreateTransaction();
            var concurencyStampMatchCondition = tran.AddCondition(Condition.HashEqual(UsersConcurencyStampIndexKey, userId, GetConcurrencyStamp(user)));
#pragma warning disable CS4014 // Because this call is not awaited, execution of the current method continues before the call is completed
            tran.HashDeleteAsync(UsersRedisKey, userId);
            tran.HashDeleteAsync(UsersNameIndexKey, user.NormalizedUserName);
            if (user.NormalizedEmail != null)
            {
                tran.HashDeleteAsync(UsersNameIndexKey, user.NormalizedEmail);
            }
#pragma warning restore CS4014 // Because this call is not awaited, execution of the current method continues before the call is completed

            if (!await tran.ExecuteAsync())
            {
                return IdentityResult.Failed(ErrorDescriber.ConcurrencyFailure());
            }

            return IdentityResult.Success;
        }

        public async override Task SetNormalizedUserNameAsync(TUser user, string normalizedName, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            if (user.NormalizedEmail == normalizedName)
            {
                return;
            }

            var userId = ConvertIdToString(user.Id);

            var tran = _db.CreateTransaction();
            var concurencyStampMatchCondition = tran.AddCondition(Condition.HashEqual(UsersConcurencyStampIndexKey, userId, GetConcurrencyStamp(user)));
#pragma warning disable CS4014 // Because this call is not awaited, execution of the current method continues before the call is completed
            if (user.NormalizedUserName != null)
            {
                tran.HashDeleteAsync(UsersNameIndexKey, user.NormalizedUserName);
            }
            if (normalizedName != null)
            {
                tran.HashSetAsync(UsersNameIndexKey, normalizedName, userId);
            }
#pragma warning restore CS4014 // Because this call is not awaited, execution of the current method continues before the call is completed

            if (!await tran.ExecuteAsync())
            {
                throw new DBConcurrencyException($&quot;ConcurrencyStamp {user.ConcurrencyStamp} doesn&#39;t match for user: {user.Id}&quot;);
            }

            user.NormalizedUserName = normalizedName;
        }

        public async override Task SetNormalizedEmailAsync(TUser user, string normalizedEmail, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            if (user.NormalizedEmail == normalizedEmail)
            {
                return;
            }

            var userId = ConvertIdToString(user.Id);

            var tran = _db.CreateTransaction();
            var concurencyStampMatchCondition = tran.AddCondition(Condition.HashEqual(UsersConcurencyStampIndexKey, userId, GetConcurrencyStamp(user)));
#pragma warning disable CS4014 // Because this call is not awaited, execution of the current method continues before the call is completed
            if (user.NormalizedEmail != null)
            {
                tran.HashDeleteAsync(UsersEmailIndexKey, user.NormalizedEmail);
            }
            if (normalizedEmail != null)
            {
                tran.HashSetAsync(UsersEmailIndexKey, normalizedEmail, userId);
            }
#pragma warning restore CS4014 // Because this call is not awaited, execution of the current method continues before the call is completed

            if (!await tran.ExecuteAsync())
            {
                throw new DBConcurrencyException($&quot;ConcurrencyStamp {user.ConcurrencyStamp} doesn&#39;t match for user: {user.Id}&quot;);
            }
            user.NormalizedEmail = normalizedEmail;
        }

        /// &lt;summary&gt;
        /// Finds and returns a user, if any, who has the specified &lt;paramref name=&quot;userId&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;userId&quot;&gt;The user ID to search for.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation, containing the user matching the specified &lt;paramref name=&quot;userId&quot;/&gt; if it exists.
        /// &lt;/returns&gt;
        public override async Task&lt;TUser&gt; FindByIdAsync(string userId, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();

            var response = await _db.HashGetAsync(UsersRedisKey, userId);
            if (response.HasValue)
            {
                var user = JsonConvert.DeserializeObject&lt;TUser&gt;(response);
                user.ConcurrencyStamp = (await _db.HashGetAsync(UsersConcurencyStampIndexKey, userId)).ToString();

                return user;
            }
            return default(TUser);
        }

        /// &lt;summary&gt;
        /// Finds and returns a user, if any, who has the specified normalized user name.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;normalizedUserName&quot;&gt;The normalized user name to search for.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation, containing the user matching the specified &lt;paramref name=&quot;normalizedUserName&quot;/&gt; if it exists.
        /// &lt;/returns&gt;
        public override async Task&lt;TUser&gt; FindByNameAsync(string normalizedUserName, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            var userId = await _db.HashGetAsync(UsersNameIndexKey, normalizedUserName);
            if (!userId.HasValue)
            {
                return default(TUser);
            }

            return await FindByIdAsync(userId, cancellationToken);
        }

        /// &lt;summary&gt;
        /// Get the claims associated with the specified &lt;paramref name=&quot;user&quot;/&gt; as an asynchronous operation.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user whose claims should be retrieved.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;A &lt;see cref=&quot;Task{TResult}&quot;/&gt; that contains the claims granted to a user.&lt;/returns&gt;
        public async override Task&lt;IList&lt;Claim&gt;&gt; GetClaimsAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            var userId = ConvertIdToString(user.Id);

            var response = await _db.HashGetAsync(UserClaimsRedisKey, userId);
            if (response.HasValue)
            {
                var claims = JsonConvert.DeserializeObject&lt;List&lt;TUserClaim&gt;&gt;(response);
                return claims.Select(c =&gt; c.ToClaim()).ToList();
            }

            return new List&lt;Claim&gt;(0);
        }

        /// &lt;summary&gt;
        /// Adds the &lt;paramref name=&quot;claims&quot;/&gt; given to the specified &lt;paramref name=&quot;user&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to add the claim to.&lt;/param&gt;
        /// &lt;param name=&quot;claims&quot;&gt;The claim to add to the user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation.&lt;/returns&gt;
        public override async Task AddClaimsAsync(TUser user, IEnumerable&lt;Claim&gt; claims, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            if (claims == null)
            {
                throw new ArgumentNullException(nameof(claims));
            }

            var userClaims = await GetUserClaimsAsync(user);

            userClaims.AddRange(claims.Select(c =&gt; CreateUserClaim(user, c)));

            var userId = ConvertIdToString(user.Id);

            var taskList = new List&lt;Task&gt;(claims.Count() + 1);
            taskList.Add(_db.HashSetAsync(UserClaimsRedisKey, userId, JsonConvert.SerializeObject(userClaims)));
            foreach (var claim in claims)
            {
                taskList.Add(_db.HashSetAsync(UserClaimsKeyPrefix + claim.Type, userId, claim.Value));
            }

            await Task.WhenAll(taskList);
        }

        /// &lt;summary&gt;
        /// Replaces the &lt;paramref name=&quot;claim&quot;/&gt; on the specified &lt;paramref name=&quot;user&quot;/&gt;, with the &lt;paramref name=&quot;newClaim&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to replace the claim on.&lt;/param&gt;
        /// &lt;param name=&quot;claim&quot;&gt;The claim replace.&lt;/param&gt;
        /// &lt;param name=&quot;newClaim&quot;&gt;The new claim replacing the &lt;paramref name=&quot;claim&quot;/&gt;.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation.&lt;/returns&gt;
        public async override Task ReplaceClaimAsync(TUser user, Claim claim, Claim newClaim, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            if (claim == null)
            {
                throw new ArgumentNullException(nameof(claim));
            }
            if (newClaim == null)
            {
                throw new ArgumentNullException(nameof(newClaim));
            }

            var userId = ConvertIdToString(user.Id);

            var userClaims = await GetUserClaimsAsync(user);
            var taskList = new List&lt;Task&gt;(3);
            await Task.WhenAll(taskList);
            foreach (var uc in userClaims)
            {
                if (uc.ClaimType == claim.Type &amp;&amp; uc.ClaimValue == claim.Value)
                {
                    uc.ClaimType = newClaim.Type;
                    uc.ClaimValue = newClaim.Value;
                    taskList.Add(_db.HashDeleteAsync(UserClaimsKeyPrefix + claim.Type, userId));
                    taskList.Add(_db.HashSetAsync(UserClaimsKeyPrefix + newClaim.Type, userId, newClaim.Value));
                }
            }

            taskList.Add(_db.HashSetAsync(UserClaimsRedisKey, userId, JsonConvert.SerializeObject(userClaims)));
            await Task.WhenAll(taskList);
        }

        /// &lt;summary&gt;
        /// Removes the &lt;paramref name=&quot;claims&quot;/&gt; given from the specified &lt;paramref name=&quot;user&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to remove the claims from.&lt;/param&gt;
        /// &lt;param name=&quot;claims&quot;&gt;The claim to remove.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation.&lt;/returns&gt;
        public async override Task RemoveClaimsAsync(TUser user, IEnumerable&lt;Claim&gt; claims, CancellationToken cancellationToken = default(CancellationToken))
        {
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            if (claims == null)
            {
                throw new ArgumentNullException(nameof(claims));
            }

            var userId = ConvertIdToString(user.Id);

            var userClaims = await GetUserClaimsAsync(user);
            var taskList = new List&lt;Task&gt;(claims.Count() + 1);
            foreach (var claim in claims)
            {
                userClaims.RemoveAll(uc =&gt; uc.ClaimType == claim.Type &amp;&amp; uc.ClaimValue == claim.Value);
                taskList.Add(_db.HashDeleteAsync(UserClaimsKeyPrefix + claim.Type, userId));
            }

            taskList.Add(_db.HashSetAsync(UserClaimsRedisKey, userId, JsonConvert.SerializeObject(userClaims)));

            await Task.WhenAll(taskList);
        }

        /// &lt;summary&gt;
        /// Adds the &lt;paramref name=&quot;login&quot;/&gt; given to the specified &lt;paramref name=&quot;user&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to add the login to.&lt;/param&gt;
        /// &lt;param name=&quot;login&quot;&gt;The login to add to the user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation.&lt;/returns&gt;
        public override async Task AddLoginAsync(TUser user, UserLoginInfo login,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            if (login == null)
            {
                throw new ArgumentNullException(nameof(login));
            }

            var userId = ConvertIdToString(user.Id);

            var logins = await GetUserLoginsAsync(userId);
            logins.Add(CreateUserLogin(user, login));

            await _db.HashSetAsync(UserLoginsRedisKey, userId, JsonConvert.SerializeObject(logins));
            await _db.HashSetAsync(UserLoginProviderKeyPrefix + login.LoginProvider, login.ProviderKey, userId);
        }

        /// &lt;summary&gt;
        /// Removes the &lt;paramref name=&quot;loginProvider&quot;/&gt; given from the specified &lt;paramref name=&quot;user&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to remove the login from.&lt;/param&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login to remove from the user.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation.&lt;/returns&gt;
        public override async Task RemoveLoginAsync(TUser user, string loginProvider, string providerKey,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            var userId = ConvertIdToString(user.Id);

            var logins = await GetUserLoginsAsync(userId);
            logins.RemoveAll(l =&gt; l.LoginProvider == loginProvider &amp;&amp; l.ProviderKey == providerKey);

            await _db.HashSetAsync(UserLoginsRedisKey, userId, JsonConvert.SerializeObject(logins));
            await _db.HashDeleteAsync(UserLoginProviderKeyPrefix + loginProvider, providerKey);
        }

        /// &lt;summary&gt;
        /// Retrieves the associated logins for the specified &lt;param ref=&quot;user&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user whose associated logins to retrieve.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The &lt;see cref=&quot;Task&quot;/&gt; for the asynchronous operation, containing a list of &lt;see cref=&quot;UserLoginInfo&quot;/&gt; for the specified &lt;paramref name=&quot;user&quot;/&gt;, if any.
        /// &lt;/returns&gt;
        public async override Task&lt;IList&lt;UserLoginInfo&gt;&gt; GetLoginsAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            var userId = ConvertIdToString(user.Id);

            var logins = await GetUserLoginsAsync(userId);

            return logins
                .Select(l =&gt; new UserLoginInfo(l.LoginProvider, l.ProviderKey, l.ProviderDisplayName))
                .ToList();
        }

        /// &lt;summary&gt;
        /// Retrieves the user associated with the specified login provider and login provider key.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login provider who provided the &lt;paramref name=&quot;providerKey&quot;/&gt;.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The &lt;see cref=&quot;Task&quot;/&gt; for the asynchronous operation, containing the user, if any which matched the specified login provider and key.
        /// &lt;/returns&gt;
        public async override Task&lt;TUser&gt; FindByLoginAsync(string loginProvider, string providerKey,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            var userLogin = await FindUserLoginAsync(loginProvider, providerKey, cancellationToken);
            if (userLogin != null)
            {
                return await FindUserAsync(userLogin.UserId, cancellationToken);
            }
            return null;
        }

        /// &lt;summary&gt;
        /// Gets the user, if any, associated with the specified, normalized email address.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;normalizedEmail&quot;&gt;The normalized email address to return the user for.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The task object containing the results of the asynchronous lookup operation, the user if any associated with the specified normalized email address.
        /// &lt;/returns&gt;
        public override async Task&lt;TUser&gt; FindByEmailAsync(string normalizedEmail, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();

            var response = await _db.HashGetAsync(UsersEmailIndexKey, normalizedEmail);
            if (response.HasValue)
            {
                return await FindByIdAsync(response, cancellationToken);
            }

            return default(TUser);
        }

        /// &lt;summary&gt;
        /// Retrieves all users with the specified claim.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;claim&quot;&gt;The claim whose users should be retrieved.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The &lt;see cref=&quot;Task&quot;/&gt; contains a list of users, if any, that contain the specified claim. 
        /// &lt;/returns&gt;
        public async override Task&lt;IList&lt;TUser&gt;&gt; GetUsersForClaimAsync(Claim claim, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (claim == null)
            {
                throw new ArgumentNullException(nameof(claim));
            }

            var result = await _db.HashGetAllAsync(UserClaimsKeyPrefix + claim.Type);

            var users = new ConcurrentBag&lt;TUser&gt;();
            var taskList = new List&lt;Task&gt;(result.Length);
            foreach (var uc in result)
            {
                taskList.Add(Task.Run(async () =&gt; {
                    var user = await FindByIdAsync(uc.Name, cancellationToken);
                    if (user != null)
                    {
                        users.Add(user);
                    }
                }));
            }

            Task.WaitAll(taskList.ToArray());

            return users.ToList();
        }

        /// &lt;summary&gt;
        /// Return a user login with the matching userId, provider, providerKey if it exists.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;userId&quot;&gt;The user&#39;s id.&lt;/param&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login provider name.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The user login if it exists.&lt;/returns&gt;
        internal Task&lt;TUserLogin&gt; FindUserLoginInternalAsync(string userId, string loginProvider, string providerKey, CancellationToken cancellationToken)
        {
            return FindUserLoginAsync(userId, loginProvider, providerKey, cancellationToken);
        }

        /// &lt;summary&gt;
        /// Return a user login with  provider, providerKey if it exists.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login provider name.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The user login if it exists.&lt;/returns&gt;
        internal Task&lt;TUserLogin&gt; FindUserLoginInternalAsync(string loginProvider, string providerKey, CancellationToken cancellationToken)
        {
            return FindUserLoginAsync(loginProvider, providerKey, cancellationToken);
        }

        /// &lt;summary&gt;
        /// Get user tokens
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The token owner.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;User tokens.&lt;/returns&gt;
        internal Task&lt;List&lt;TUserToken&gt;&gt; GetUserTokensInternalAsync(TUser user, CancellationToken cancellationToken)
        {
            return GetUserTokensAsync(user, cancellationToken);
        }

        /// &lt;summary&gt;
        /// Save user tokens.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The tokens owner.&lt;/param&gt;
        /// &lt;param name=&quot;tokens&quot;&gt;Tokens to save&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        internal Task SaveUserTokensInternalAsync(TUser user, IEnumerable&lt;TUserToken&gt; tokens, CancellationToken cancellationToken)
        {
            return SaveUserTokensAsync(user, tokens, cancellationToken);
        }
        
        /// &lt;summary&gt;
        /// Return a user with the matching userId if it exists.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;userId&quot;&gt;The user&#39;s id.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The user if it exists.&lt;/returns&gt;
        protected override Task&lt;TUser&gt; FindUserAsync(TKey userId, CancellationToken cancellationToken)
        {
            return FindByIdAsync(userId.ToString(), cancellationToken);
        }

        /// &lt;summary&gt;
        /// Return a user login with the matching userId, provider, providerKey if it exists.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;userId&quot;&gt;The user&#39;s id.&lt;/param&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login provider name.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The user login if it exists.&lt;/returns&gt;
        protected override async Task&lt;TUserLogin&gt; FindUserLoginAsync(string userId, string loginProvider, string providerKey, CancellationToken cancellationToken)
        {
            var data = await GetUserLoginsAsync(userId);
            if (data != null)
            {
                return data.FirstOrDefault(l =&gt; l.LoginProvider == loginProvider &amp;&amp; l.ProviderKey == providerKey);
            }
            return null;
        }

        /// &lt;summary&gt;
        /// Return a user login with  provider, providerKey if it exists.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login provider name.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The user login if it exists.&lt;/returns&gt;
        protected override async Task&lt;TUserLogin&gt; FindUserLoginAsync(string loginProvider, string providerKey, CancellationToken cancellationToken)
        {
            var userId = await _db.HashGetAsync(UserLoginProviderKeyPrefix + loginProvider, providerKey);

            if (userId.HasValue)
            {
                var logins = await GetUserLoginsAsync(userId);
                return logins.FirstOrDefault(l =&gt; l.LoginProvider == loginProvider &amp;&amp; l.ProviderKey == providerKey);
            }

            return default(TUserLogin);
        }

        /// &lt;summary&gt;
        /// Get user tokens
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The token owner.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;User tokens.&lt;/returns&gt;
        protected override async Task&lt;List&lt;TUserToken&gt;&gt; GetUserTokensAsync(TUser user, CancellationToken cancellationToken)
        {
            var userId = ConvertIdToString(user.Id);

            var result = await _db.HashGetAsync(UserTokensRedisKey, userId);
            if (result.HasValue)
            {
                return JsonConvert.DeserializeObject&lt;List&lt;TUserToken&gt;&gt;(result);
            }
            return new List&lt;TUserToken&gt;(0);
        }

        /// &lt;summary&gt;
        /// Save user tokens.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The tokens owner.&lt;/param&gt;
        /// &lt;param name=&quot;tokens&quot;&gt;Tokens to save&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        protected override async Task SaveUserTokensAsync(TUser user, IEnumerable&lt;TUserToken&gt; tokens, CancellationToken cancellationToken)
        {
            var userId = ConvertIdToString(user.Id);

            await _db.HashSetAsync(UserTokensRedisKey, userId, JsonConvert.SerializeObject(tokens));
        }

        protected virtual async Task&lt;List&lt;TUserClaim&gt;&gt; GetUserClaimsAsync(TUser user)
        {
            var userId = ConvertIdToString(user.Id);

            var response = await _db.HashGetAsync(UserClaimsRedisKey, userId);
            if (response.HasValue)
            {
                return JsonConvert.DeserializeObject&lt;List&lt;TUserClaim&gt;&gt;(response);
            }

            return new List&lt;TUserClaim&gt;();
        }

        protected virtual async Task&lt;List&lt;TUserLogin&gt;&gt; GetUserLoginsAsync(string userId)
        {
            var response = await _db.HashGetAsync(UserLoginsRedisKey, userId);
            if (response.HasValue)
            {
                return JsonConvert.DeserializeObject&lt;List&lt;TUserLogin&gt;&gt;(response);
            }

            return new List&lt;TUserLogin&gt;();
        }

        private static int? GetConcurrencyStamp(TUser user)
        {
            if (int.TryParse(user.ConcurrencyStamp, out int stamp))
            {
                return stamp;
            }
            return null;
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[26,87,26,106,1],[26,107,26,108,1],[26,109,26,110,1],[40,87,40,106,1],[40,107,40,108,1],[40,109,40,110,1],[56,87,56,106,1],[56,107,56,108,1],[56,109,56,110,1],[103,13,103,14,1],[104,17,104,61,1],[105,17,105,44,1],[105,44,105,89,1],[105,89,106,36,1],[105,17,106,36,1],[107,13,107,14,1],[115,87,115,134,1],[116,9,116,10,1],[117,13,117,69,1],[118,9,118,10,1],[127,9,127,10,1],[128,13,128,62,1],[129,13,129,31,1],[130,13,130,30,1],[131,13,131,14,1],[132,17,132,63,1],[135,13,135,53,1],[137,13,137,41,1],[138,13,138,48,1],[139,13,139,108,1],[141,13,141,89,1],[142,13,142,96,1],[143,13,143,83,1],[144,13,144,61,1],[145,13,145,14,1],[146,17,146,85,1],[147,13,147,14,1],[150,13,150,44,1],[151,13,151,14,0],[152,17,156,20,0],[159,13,159,43,1],[160,9,160,10,1],[169,9,169,10,1],[170,13,170,62,1],[171,13,171,31,1],[172,13,172,30,1],[173,13,173,14,1],[174,17,174,63,1],[177,13,177,53,1],[179,13,179,48,1],[180,13,180,117,1],[182,13,182,89,1],[183,13,183,92,1],[184,13,184,83,1],[185,13,185,61,1],[186,13,186,14,1],[187,17,187,85,1],[188,13,188,14,1],[191,13,191,44,1],[192,13,192,14,0],[193,17,193,83,0],[195,13,195,66,1],[197,13,197,43,1],[198,9,198,10,1],[207,9,207,10,1],[208,13,208,62,1],[209,13,209,31,1],[210,13,210,30,1],[211,13,211,14,1],[212,17,212,63,1],[215,13,215,53,1],[217,13,217,48,1],[218,13,218,153,1],[220,13,220,57,1],[221,13,221,78,1],[222,13,222,46,1],[223,13,223,14,1],[224,17,224,79,1],[225,13,225,14,1],[228,13,228,44,1],[229,13,229,14,0],[230,17,230,83,0],[233,13,233,43,1],[234,9,234,10,1],[237,9,237,10,1],[238,13,238,62,1],[239,13,239,31,1],[240,13,240,30,1],[241,13,241,14,0],[242,17,242,63,0],[244,13,244,56,1],[245,13,245,14,0],[246,17,246,24,0],[249,13,249,53,1],[251,13,251,48,1],[252,13,252,153,1],[254,13,254,49,1],[255,13,255,14,1],[256,17,256,82,1],[257,13,257,14,1],[258,13,258,40,1],[259,13,259,14,1],[260,17,260,78,1],[261,13,261,14,1],[264,13,264,44,1],[265,13,265,14,0],[266,17,266,129,0],[269,13,269,54,1],[270,9,270,10,1],[273,9,273,10,1],[274,13,274,62,1],[275,13,275,31,1],[276,13,276,30,1],[277,13,277,14,0],[278,17,278,63,0],[280,13,280,57,1],[281,13,281,14,1],[282,17,282,24,1],[285,13,285,53,1],[287,13,287,48,1],[288,13,288,153,1],[290,13,290,46,1],[291,13,291,14,1],[292,17,292,80,1],[293,13,293,14,1],[294,13,294,41,1],[295,13,295,14,1],[296,17,296,80,1],[297,13,297,14,1],[300,13,300,44,1],[301,13,301,14,0],[302,17,302,129,0],[304,13,304,52,1],[305,9,305,10,1],[316,9,316,10,1],[317,13,317,62,1],[318,13,318,31,1],[320,13,320,74,1],[321,13,321,35,1],[322,13,322,14,1],[323,17,323,75,1],[324,17,324,115,1],[326,17,326,29,1],[328,13,328,35,1],[329,9,329,10,1],[340,9,340,10,1],[341,13,341,62,1],[342,13,342,31,1],[343,13,343,88,1],[344,13,344,34,1],[345,13,345,14,1],[346,17,346,39,1],[349,13,349,67,1],[350,9,350,10,1],[359,9,359,10,1],[360,13,360,62,1],[361,13,361,31,1],[362,13,362,30,1],[363,13,363,14,1],[364,17,364,63,1],[367,13,367,53,1],[369,13,369,79,1],[370,13,370,35,1],[371,13,371,14,1],[372,17,372,88,1],[373,17,373,43,1],[373,43,373,54,1],[373,54,373,65,1],[373,17,373,65,1],[376,13,376,39,0],[377,9,377,10,1],[387,9,387,10,1],[388,13,388,62,1],[389,13,389,31,1],[390,13,390,30,1],[391,13,391,14,1],[392,17,392,63,1],[394,13,394,32,1],[395,13,395,14,1],[396,17,396,65,1],[399,13,399,61,1],[401,13,401,52,1],[401,52,401,76,1],[401,76,401,79,1],[401,13,401,79,1],[403,13,403,53,1],[405,13,405,63,1],[406,13,406,113,1],[407,13,407,20,1],[407,22,407,31,1],[407,32,407,34,1],[407,35,407,41,1],[408,13,408,14,1],[409,17,409,103,1],[410,13,410,14,1],[412,13,412,42,1],[413,9,413,10,1],[424,9,424,10,1],[425,13,425,62,1],[426,13,426,31,1],[427,13,427,30,1],[428,13,428,14,1],[429,17,429,63,1],[431,13,431,31,1],[432,13,432,14,0],[433,17,433,64,0],[435,13,435,34,1],[436,13,436,14,0],[437,17,437,67,0],[440,13,440,53,1],[442,13,442,61,1],[443,13,443,46,1],[444,13,444,42,1],[445,13,445,20,1],[445,22,445,28,1],[445,29,445,31,1],[445,32,445,42,1],[446,13,446,14,1],[447,17,447,80,1],[448,17,448,18,1],[449,21,449,50,1],[450,21,450,52,1],[451,21,451,97,1],[452,21,452,113,1],[453,17,453,18,1],[454,13,454,14,1],[456,13,456,113,1],[457,13,457,42,1],[458,9,458,10,1],[468,9,468,10,1],[469,13,469,31,1],[470,13,470,30,1],[471,13,471,14,1],[472,17,472,63,1],[474,13,474,32,1],[475,13,475,14,1],[476,17,476,65,1],[479,13,479,53,1],[481,13,481,61,1],[482,13,482,63,1],[483,13,483,20,1],[483,22,483,31,1],[483,32,483,34,1],[483,35,483,41,1],[484,13,484,14,1],[485,17,485,44,1],[485,44,485,102,1],[485,102,485,104,1],[485,17,485,104,1],[486,17,486,93,1],[487,13,487,14,1],[489,13,489,113,1],[491,13,491,42,1],[492,9,492,10,1],[503,9,503,10,1],[504,13,504,62,1],[505,13,505,31,1],[506,13,506,30,1],[507,13,507,14,1],[508,17,508,63,1],[510,13,510,31,1],[511,13,511,14,1],[512,17,512,64,1],[515,13,515,53,1],[517,13,517,59,1],[518,13,518,54,1],[520,13,520,101,1],[521,13,521,113,1],[522,9,522,10,1],[534,9,534,10,1],[535,13,535,62,1],[536,13,536,31,1],[537,13,537,30,1],[538,13,538,14,1],[539,17,539,63,1],[542,13,542,53,1],[544,13,544,59,1],[545,13,545,35,1],[545,35,545,99,1],[545,99,545,101,1],[545,13,545,101,1],[547,13,547,101,1],[548,13,548,96,1],[549,9,549,10,1],[560,9,560,10,1],[561,13,561,62,1],[562,13,562,31,1],[563,13,563,30,1],[564,13,564,14,1],[565,17,565,63,1],[568,13,568,53,1],[570,13,570,59,1],[572,13,573,30,1],[573,30,573,102,1],[573,102,574,27,1],[572,13,574,27,1],[575,9,575,10,1],[588,9,588,10,1],[589,13,589,62,1],[590,13,590,31,1],[591,13,591,101,1],[592,13,592,35,1],[593,13,593,14,1],[594,17,594,81,1],[596,13,596,25,1],[597,9,597,10,1],[608,9,608,10,1],[609,13,609,62,1],[610,13,610,31,1],[612,13,612,88,1],[613,13,613,35,1],[614,13,614,14,1],[615,17,615,73,1],[618,13,618,35,1],[619,9,619,10,1],[630,9,630,10,1],[631,13,631,62,1],[632,13,632,31,1],[633,13,633,31,1],[634,13,634,14,0],[635,17,635,64,0],[638,13,638,86,1],[640,13,640,52,1],[641,13,641,58,1],[642,13,642,20,1],[642,22,642,28,1],[642,29,642,31,1],[642,32,642,38,1],[643,13,643,14,1],[644,17,644,51,1],[644,51,644,52,1],[644,52,645,21,1],[645,21,645,80,1],[645,80,646,21,1],[646,21,646,38,1],[646,38,647,21,1],[647,21,647,22,1],[647,22,648,25,1],[648,25,648,41,1],[648,41,649,21,1],[649,21,649,22,1],[649,22,650,17,1],[650,17,650,18,1],[650,18,650,21,1],[644,17,650,21,1],[651,13,651,14,1],[653,13,653,46,1],[655,13,655,35,1],[656,9,656,10,1],[667,9,667,10,0],[668,13,668,94,0],[669,9,669,10,0],[679,9,679,10,0],[680,13,680,86,0],[681,9,681,10,0],[690,9,690,10,1],[691,13,691,64,1],[692,9,692,10,1],[702,9,702,10,1],[703,13,703,73,1],[704,9,704,10,1],[713,9,713,10,1],[714,13,714,72,1],[715,9,715,10,1],[726,9,726,10,0],[727,13,727,57,0],[728,13,728,30,0],[729,13,729,14,0],[730,17,730,49,0],[730,49,730,113,0],[730,113,730,115,0],[730,17,730,115,0],[732,13,732,25,0],[733,9,733,10,0],[743,9,743,10,1],[744,13,744,106,1],[746,13,746,33,1],[747,13,747,14,1],[748,17,748,63,1],[749,17,749,51,1],[749,51,749,115,1],[749,115,749,117,1],[749,17,749,117,1],[752,13,752,40,1],[753,9,753,10,1],[762,9,762,10,1],[763,13,763,53,1],[765,13,765,77,1],[766,13,766,33,1],[767,13,767,14,1],[768,17,768,80,1],[770,13,770,44,1],[771,9,771,10,1],[781,9,781,10,1],[782,13,782,53,1],[784,13,784,101,1],[785,9,785,10,1],[788,9,788,10,1],[789,13,789,53,1],[791,13,791,79,1],[792,13,792,35,1],[793,13,793,14,1],[794,17,794,82,1],[797,13,797,43,1],[798,9,798,10,1],[801,9,801,10,1],[802,13,802,79,1],[803,13,803,35,1],[804,13,804,14,1],[805,17,805,82,1],[808,13,808,43,1],[809,9,809,10,1],[812,9,812,10,1],[813,13,813,68,1],[814,13,814,14,1],[815,17,815,30,1],[817,13,817,25,1],[818,9,818,10,1]]);
    </script>
  </body>
</html>